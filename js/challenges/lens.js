window.LENS_CHALLENGES = [
    {
        id: "lens-list-comp-nested-if",
        tier: 2,
        tags: ["list-comprehension", "conditionals"],
        title: "Nested Conditions in List Comprehension",
        code: "numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nresult = [x for x in numbers if x > 3 if x % 2 == 0]\nprint(result)",
        isCorrect: true,
        correctOutput: "[4, 6, 8, 10]",
        outputChoices: [
            "[4, 6, 8, 10]",
            "[2, 4, 6, 8, 10]",
            "[4, 5, 6, 7, 8, 9, 10]",
            "SyntaxError"
        ],
        bugLine: null,
        bugDescription: null,
        bugChoices: null,
        correctBugChoice: null,
        fixedCode: null,
        explanation: "This code is CORRECT. Multiple 'if' clauses in a list comprehension act as AND conditions. The expression 'if x > 3 if x % 2 == 0' is equivalent to 'if x > 3 and x % 2 == 0'. This filters for numbers greater than 3 AND even, giving us [4, 6, 8, 10]. While it looks unusual, this syntax is valid and works as expected.",
        conceptLink: "https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions"
    },
    {
        id: "lens-or-default-falsy",
        tier: 1,
        tags: ["boolean-logic", "default-values"],
        title: "Default Value with Or Operator",
        code: "def get_quantity(user_input):\n    # Set default quantity to 10 if not provided\n    quantity = user_input or 10\n    return quantity\n\nresult = get_quantity(0)\nprint(result)",
        isCorrect: false,
        correctOutput: null,
        outputChoices: null,
        bugLine: 3,
        bugDescription: "The 'or' operator treats 0 as falsy, so it returns 10 instead of 0",
        bugChoices: [
            "The 'or' operator treats 0 as falsy, so it returns 10 instead of 0",
            "The function should use 'and' instead of 'or'",
            "user_input needs to be converted to int first",
            "The default value should be defined as a function parameter"
        ],
        correctBugChoice: 0,
        fixedCode: "def get_quantity(user_input):\n    # Set default quantity to 10 if not provided\n    quantity = user_input if user_input is not None else 10\n    return quantity\n\nresult = get_quantity(0)\nprint(result)",
        explanation: "This code is BUGGY. The 'or' operator returns the first truthy value. Since 0 is falsy in Python, 'user_input or 10' returns 10 even when user_input is 0. This is a common mistake when setting default values. The correct output should be 0, but the code outputs 10. Use 'if user_input is not None else 10' or check for None explicitly to handle falsy values like 0, empty strings, or empty lists correctly.",
        conceptLink: "https://docs.python.org/3/library/stdtypes.html#truth-value-testing"
    },
    {
        id: "lens-tuple-comparison",
        tier: 2,
        tags: ["tuples", "comparison"],
        title: "Lexicographic Tuple Comparison",
        code: "coords1 = (1, 2)\ncoords2 = (1, 3)\ncoords3 = (2, 1)\n\nresult = (coords1 < coords2 < coords3)\nprint(result)",
        isCorrect: true,
        correctOutput: "True",
        outputChoices: [
            "True",
            "False",
            "TypeError",
            "(True, False)"
        ],
        bugLine: null,
        bugDescription: null,
        bugChoices: null,
        correctBugChoice: null,
        fixedCode: null,
        explanation: "This code is CORRECT. Python compares tuples lexicographically (like dictionary order). It first compares the first elements; if equal, it compares the second elements, and so on. Here: (1,2) < (1,3) because first elements are equal and 2 < 3. Then (1,3) < (2,1) because 1 < 2 (first element comparison is enough). The chained comparison works as expected, returning True.",
        conceptLink: "https://docs.python.org/3/reference/expressions.html#value-comparisons"
    },
    {
        id: "lens-dict-comp-duplicates",
        tier: 2,
        tags: ["dictionary", "comprehension"],
        title: "Dictionary from Pairs with Duplicates",
        code: "# Create dict from pairs, keeping first occurrence of each key\npairs = [('a', 1), ('b', 2), ('a', 3), ('c', 4)]\nresult = {key: value for key, value in pairs}\nprint(result)",
        isCorrect: false,
        correctOutput: null,
        outputChoices: null,
        bugLine: 3,
        bugDescription: "Dict comprehension keeps the last value for duplicate keys, not the first",
        bugChoices: [
            "Dict comprehension keeps the last value for duplicate keys, not the first",
            "The syntax should use dict() constructor instead",
            "Dictionary keys must be unique, this raises a ValueError",
            "The comprehension needs if key not in result condition"
        ],
        correctBugChoice: 0,
        fixedCode: "# Create dict from pairs, keeping first occurrence of each key\npairs = [('a', 1), ('b', 2), ('a', 3), ('c', 4)]\nresult = {}\nfor key, value in pairs:\n    if key not in result:\n        result[key] = value\nprint(result)",
        explanation: "This code is BUGGY. The comment says to keep the first occurrence, but dictionary comprehensions process items sequentially and overwrite values for duplicate keys. When 'a' appears twice with values 1 and 3, the last value (3) is kept. The output is {'a': 3, 'b': 2, 'c': 4} instead of the intended {'a': 1, 'b': 2, 'c': 4}. To keep the first occurrence, use a loop with a conditional check or dict with reversed comprehension.",
        conceptLink: "https://docs.python.org/3/tutorial/datastructures.html#dictionaries"
    },
    {
        id: "lens-chained-string-methods",
        tier: 1,
        tags: ["strings", "methods"],
        title: "Chained String Method Calls",
        code: "text = \"  Hello World  \"\nresult = text.strip().lower().replace('world', 'python')\nprint(result)",
        isCorrect: true,
        correctOutput: "hello python",
        outputChoices: [
            "hello python",
            "Hello Python",
            "  hello python  ",
            "AttributeError"
        ],
        bugLine: null,
        bugDescription: null,
        bugChoices: null,
        correctBugChoice: null,
        fixedCode: null,
        explanation: "This code is CORRECT. String methods in Python return new strings and can be chained safely. The execution goes left to right: strip() removes leading/trailing whitespace giving 'Hello World', lower() converts to 'hello world', and replace() changes 'world' to 'python' giving 'hello python'. Each method returns a string object, so the next method can be called on it. This is a common and reliable pattern in Python.",
        conceptLink: "https://docs.python.org/3/library/stdtypes.html#string-methods"
    },
    {
        id: "lens-in-operator-dict",
        tier: 1,
        tags: ["dictionary", "membership"],
        title: "Checking Dictionary Membership",
        code: "# Check if user's favorite color is in our palette\npalette = {'red': '#FF0000', 'blue': '#0000FF', 'green': '#00FF00'}\nfavorite = '#FF0000'\nif favorite in palette:\n    print(\"Color found!\")\nelse:\n    print(\"Color not found!\")",
        isCorrect: false,
        correctOutput: null,
        outputChoices: null,
        bugLine: 4,
        bugDescription: "The 'in' operator checks dictionary keys, not values; should check palette.values()",
        bugChoices: [
            "The 'in' operator checks dictionary keys, not values; should check palette.values()",
            "The comparison should use == instead of 'in'",
            "Dictionary membership requires both key and value",
            "The favorite variable should be converted to a string first"
        ],
        correctBugChoice: 0,
        fixedCode: "# Check if user's favorite color is in our palette\npalette = {'red': '#FF0000', 'blue': '#0000FF', 'green': '#00FF00'}\nfavorite = '#FF0000'\nif favorite in palette.values():\n    print(\"Color found!\")\nelse:\n    print(\"Color not found!\")",
        explanation: "This code is BUGGY. The comment suggests checking if a color value is in the palette, but the 'in' operator on a dictionary checks keys, not values. Since '#FF0000' is a value (not a key like 'red'), the condition is False and it prints 'Color not found!' instead of 'Color found!'. To check values, use 'if favorite in palette.values()'. This is a common mistake when working with dictionaries.",
        conceptLink: "https://docs.python.org/3/library/stdtypes.html#mapping-types-dict"
    },
    {
        id: "lens-fibonacci-swap",
        tier: 2,
        tags: ["assignment", "tuple-unpacking"],
        title: "Simultaneous Assignment in Loop",
        code: "# Generate Fibonacci sequence\na, b = 0, 1\nfor _ in range(5):\n    print(a)\n    a, b = b, a + b",
        isCorrect: true,
        correctOutput: "0\n1\n1\n2\n3",
        outputChoices: [
            "0\n1\n1\n2\n3",
            "0\n1\n2\n3\n5",
            "1\n1\n2\n3\n5",
            "0\n0\n0\n0\n0"
        ],
        bugLine: null,
        bugDescription: null,
        bugChoices: null,
        correctBugChoice: null,
        fixedCode: null,
        explanation: "This code is CORRECT. The simultaneous assignment 'a, b = b, a + b' works perfectly for Fibonacci generation. Python evaluates all expressions on the right side BEFORE assigning to the left side. So it calculates both 'b' and 'a + b' using the OLD values of a and b, then assigns them simultaneously. This is equivalent to: temp_a = b; temp_b = a + b; a = temp_a; b = temp_b. The output is the first 5 Fibonacci numbers: 0, 1, 1, 2, 3.",
        conceptLink: "https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences"
    },
    {
        id: "lens-list-multiplication-nested",
        tier: 2,
        tags: ["lists", "mutability", "references"],
        title: "Creating a 2D Grid with Multiplication",
        code: "# Create a 3x3 grid initialized to zeros\ngrid = [[0] * 3] * 3\ngrid[0][0] = 1\nprint(grid)",
        isCorrect: false,
        correctOutput: null,
        outputChoices: null,
        bugLine: 2,
        bugDescription: "List multiplication creates references to the same inner list, so modifying one row affects all rows",
        bugChoices: [
            "List multiplication creates references to the same inner list, so modifying one row affects all rows",
            "The syntax should use nested for loops instead of multiplication",
            "Lists cannot be multiplied by integers in Python",
            "The index [0][0] is out of bounds for this grid"
        ],
        correctBugChoice: 0,
        fixedCode: "# Create a 3x3 grid initialized to zeros\ngrid = [[0] * 3 for _ in range(3)]\ngrid[0][0] = 1\nprint(grid)",
        explanation: "This code is BUGGY. The expression '[[0] * 3] * 3' creates one list [0, 0, 0] and then creates 3 references to that SAME list. When you modify grid[0][0], you're modifying the shared list, so ALL rows change. The output is [[1, 0, 0], [1, 0, 0], [1, 0, 0]] instead of [[1, 0, 0], [0, 0, 0], [0, 0, 0]]. Use a list comprehension '[[0] * 3 for _ in range(3)]' to create independent lists for each row.",
        conceptLink: "https://docs.python.org/3/faq/programming.html#how-do-i-create-a-multidimensional-list"
    },
    {
        id: "lens-short-circuit-side-effects",
        tier: 2,
        tags: ["boolean-logic", "short-circuit"],
        title: "Short-Circuit with Function Calls",
        code: "def check_positive(x):\n    print(f\"Checking {x}\")\n    return x > 0\n\nresult = check_positive(-5) and check_positive(10)\nprint(f\"Result: {result}\")",
        isCorrect: true,
        correctOutput: "Checking -5\nResult: False",
        outputChoices: [
            "Checking -5\nResult: False",
            "Checking -5\nChecking 10\nResult: False",
            "Checking 10\nResult: False",
            "Result: False"
        ],
        bugLine: null,
        bugDescription: null,
        bugChoices: null,
        correctBugChoice: null,
        fixedCode: null,
        explanation: "This code is CORRECT. Python's 'and' operator uses short-circuit evaluation: if the left operand is falsy, it returns that value without evaluating the right operand. Since check_positive(-5) returns False, the second function check_positive(10) is never called. This is why we only see 'Checking -5' printed, not 'Checking 10'. The final result is False. Short-circuit evaluation is a feature, not a bug, and is used for optimization and conditional execution.",
        conceptLink: "https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not"
    },
    {
        id: "lens-round-bankers-rounding",
        tier: 2,
        tags: ["rounding", "floating-point"],
        title: "Rounding Half Values",
        code: "# Round measurements to nearest integer\nvalues = [0.5, 1.5, 2.5, 3.5]\nrounded = [round(x) for x in values]\nprint(rounded)",
        isCorrect: false,
        correctOutput: null,
        outputChoices: null,
        bugLine: 3,
        bugDescription: "round() uses banker's rounding (round half to even), so 0.5 rounds to 0, not 1",
        bugChoices: [
            "round() uses banker's rounding (round half to even), so 0.5 rounds to 0, not 1",
            "The round() function requires two arguments",
            "List comprehension cannot be used with round()",
            "Floating point values must be converted to Decimal first"
        ],
        correctBugChoice: 0,
        fixedCode: "# Round measurements to nearest integer\nimport math\nvalues = [0.5, 1.5, 2.5, 3.5]\nrounded = [math.floor(x + 0.5) for x in values]\nprint(rounded)",
        explanation: "This code is BUGGY if you expect traditional rounding (0.5 rounds up). Python 3's round() uses 'banker's rounding' (round half to even): 0.5→0, 1.5→2, 2.5→2, 3.5→4. The output is [0, 2, 2, 4], not [1, 2, 3, 4]. This reduces bias in statistical calculations but surprises many developers. If you need traditional rounding (always round 0.5 up), use math.floor(x + 0.5) or import decimal. This behavior is documented but commonly misunderstood.",
        conceptLink: "https://docs.python.org/3/library/functions.html#round"
    }
];
